'use strict';
/*
Singletons Ã¢â‚¬â€œ Each component dependent on a service gets a reference to the 
single instance generated by the service factory
	factory services
 */
angular.module('intranet')
.factory('services', ['$http', '$rootScope','localStorageService', '$log', '$q', '$compile', '$mdToast', 
	function ($http,$rootScope, localStorageService, log, $q, $compile, $mdToast) {
	var _this = this;

	var services = {};

	services.saveLocal =  (key, data) => {
		if (!data) {
			return false;
		}
		localStorageService.set(key, data, "sessionStorage");
		return localStorageService.get(key, "sessionStorage");
		 
	};


	services.deleteSavedLocal = function (key) {
		if (!key) {
			return false;
		}
		return localStorageService.remove(key, "sessionStorage");
	};
	

	services.getSaveLocal = function (key) {
		if (!key) { return false; }
		
		var data = localStorageService.get(key, "sessionStorage");
		if (data) {
			return localStorageService.get(key, "sessionStorage");
		} else {
			return false;
		}
	};
	services.getError = function (data) {

		if (data) {
			var obj = {};
			obj.type = data.type;
			
			obj.message = data.errors ? data.errors[0] : data.message;

			return obj;
		} else {
			return false;
		}
	};

	services.notify = function (message, type, obj) {
		if(!message) { return ; }
		$mdToast.show({
			hideDelay: 9000,
			position: 'top right',
			controller: 'notifyCtrl',
			template: `
				<md-toast class="alert-toster">
					<div layout="row" layout-align="space-between center" class="md-block">
					  <span class="md-toast-text" flex>{{message.message}}</span>
					  <md-button ng-if="message.data" class="md-icon-button white-icon" ng-click="redirect()" aria-label="redirect">
					    	<md-icon >info_outline</md-icon>
					    	<md-tooltip>Open/View</md-tooltip>
					  </md-button>
					  <md-button class="md-icon-button button-close" ng-click="close()" aria-label="close">
					    	<md-icon >close</md-icon>
					  </md-button>
				  </div>
				</md-toast>`,
			toastClass: type,
			locals: { message: { message: message, data: obj } }
		});
	};

	//set session object
	/**
  * [set object data on local cookies]
  * @param {object} obj JSON.object
  */
 	_this.keys = '-user';

  	services.setCookies = (obj) => {
  		if (!obj) {
			log.warn('Provide session object to set for local cookies');
		}

  		 let user = {name:obj.name, token:obj.token, email:obj.email, image:obj.image};
  		 localStorageService.cookie.set(_this.keys, user);
  		 return localStorageService.cookie.get(_this.keys);
  	};
  	
  	services.removeCookies = () => {
  		localStorageService.cookie.remove(_this.keys);
  		return false;
  	};

	services.setSession = function (obj) {

		if (!obj) {
			log.warn('Provide session object to set for local cookies');
		}
		
		if(obj.remember){
			services.setCookies(obj);
		}else{
			services.removeCookies();
		}
		localStorageService.set(_this.keys, obj, "sessionStorage");
		return services.getSession();
	};


	//get session object if exist
	/**
  * [getSession get Session data form local]
  * @return {object} [return json.object user object]
  */

	services.getSession = function () {
		let session = localStorageService.cookie.get(_this.keys) ;
		let user ={};
		if(session) {
			user.session =session;
		}
		if(localStorageService.get(_this.keys,"sessionStorage")) {
			user.user =localStorageService.get(_this.keys,"sessionStorage");
		}
		if(user) {
			return user;
		} 
		else { 
			return {};
		}
		

	};

	
	/**
  * [clear all seesion data]
  * @return true or false
  */
	services.removeSession = function () {
		// _this.keys = '-user';
		// localStorageService.cookie.remove(_this.keys);
		localStorageService.remove(_this.keys, "sessionStorage");
		localStorageService.clearAll();
		return false;
	};

	

	/**
  * [$http request method]
  * @param  {object} obj [http request object {method:'POST',url:'url'}]
  * @return {promise}     [return response object]
  */
	services.http = function (obj) {

		return $q(function (resolve, reject) {
			return $http(obj).then(function (response) {

				if(response.data.type==='success'){
					return resolve(response.data);
				}
				if(response.data.type==='error'){
					return reject(response.data);
				}
			}, error =>  {
			
				if(error.status ===-1) {
					services.notify('Disconnected from server, Server is probably not available', 'error');
				}
				return reject(error.data);
			});
		});
	};

	/**
  * [description]
  * @param  {html template} html  [description]
  * @param  {scope variable} scope [description]
  * @return {string  compile with scope}       [description]
  */
	services.HTMLcompile = function (html, scope) {
		var compiled = $compile(html)(scope);
		return compiled[0];
	};
	

	/**
  * [get address form google API based on query]
  * @param  {[type]} query [description]
  * @return {[type]}       [description]
  */
	services.getAddress = function (query) {

		if (!query) {
			return;
		}

		return $http.get('//maps.googleapis.com/maps/api/geocode/json', {
			params: {
				address: query
			},
			cache: true
		}).then(function (response) {
			if (!response) {
				return;
			}

			return response.data.results.map(function (item) {

				var address_compoments = void 0;

				item.address = services.formatted_address(item.address_components, item.formatted_address);

				var location = item.geometry;
				delete item.geometry;
				delete item.address_components;
				delete item.types;
				delete item.place_id;
				item.geometry = location.location;
				item.location = {
					coordinates: [location.location.lng, location.location.lat],
					type: "Point"
				};
				return item;
			});
		});
	};

	services.formatted_address = function (obj, formatted_address) {

		if (!angular.isArray(obj)) {
			return obj + ' is not an array';
		}
		var tmp = {};

		obj.map(function (x) {

			if (x.types.indexOf('locality') > -1) {
				tmp.city = x.long_name;
			}
			if (x.types.indexOf('administrative_area_level_1') > -1 || x.types.indexOf('administrative_area_level_2') > -1) {
				tmp.state = x.long_name;
			}
			if (x.types.indexOf('country') > -1) {
				tmp.country = x.long_name;
			}
			if (x.types.indexOf('postal_code') > -1) {
				tmp.postal_code = x.long_name;
			}
			if (x.types.indexOf('sublocality_level_1') > -1) {
				tmp.locality = x.long_name;
			}
			if (x.types.indexOf('sublocality_level_1') > -1 || x.types.indexOf('sublocality') > -1) {
				tmp.sublocality = x.long_name;
			}
			if (x.types.indexOf('street_number') > -1) {
				tmp.sublocality = formatted_address.split(',')[0];
			}
		});
		return tmp;
	};

	return services;
}]);